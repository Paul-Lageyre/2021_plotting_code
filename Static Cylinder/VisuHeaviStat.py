#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Tue Jul  7 15:42:58 2020

@author: paulg

Programme de visualisation simple de fonctions par parties (combinaison de heavisides) en 2D colormap et 3D
"""

from mpl_toolkits import mplot3d

from matplotlib import cm
import numpy as np
import matplotlib.pyplot as plt
# from matplotlib.animation import FuncAnimation
from mpl_toolkits.axes_grid1 import make_axes_locatable


"""
FONCTIONS CONDITIONS
"""

def SqrP(z,t,R):
    return z-np.sqrt(t**2-R^2) 

def Sqrm(z,t,R):
    return z+np.sqrt(t**2-R^2) 

"""
PRIMITIVES DES FONCTIONS
"""

def zabs(v,z,t,R): # v represents the integration variable
    return -(0.25*(v*(v-2*z)*np.sign(v-z)+2*z**2*np.heaviside(v-z,0.5)))

def ct(v,z,t,R):
    return 0.5*v*t

def Rplusz(v,z,t,R):
    return 0.25*((v-z)*np.sqrt(R**2 + (v-z)**2)+ R**2 * np.arcsinh((v-z)/R))

"""
SOLUTION COMPLETE
"""

def Solution(L,R,z,t):
    z=np.array(z)
    t=np.array(t)
    CondGen=np.array([t>=0]) # General conditions list. Solution is 0 if not verified
    BMaxGen=[z+t,L*np.ones(np.shape(z))] # General upper bounds
    BminGen=[z-t,0*np.ones(np.shape(z))] # General lower bounds
    
    FoncList=[zabs,ct,ct,ct,Rplusz] #Function list. Functions are repeated if its associated conditions are written as sum of Heaviside functions
    BMaxLoc=[[],[],[z-np.sqrt(t**2 - R**2)],[],[z+np.sqrt(t**2 - R**2)]] #Associated upper bounds
    BminLoc=[[],[],[],[z+np.sqrt(t**2 - R**2)],[z-np.sqrt(t**2 - R**2)]] #Associated lower bounds

    for k,i in enumerate(BMaxLoc): # General bounds are added to local bounds list
        i+=BMaxGen
        BMaxLoc[k]=np.array(i) # Lists turned into array to apply numpy functions
        BMaxLoc[k][np.isnan(BMaxLoc[k])]=0 # Remplaces NaNs generated by functions out of their domain by 0
    for l,j in enumerate(BminLoc):
        j+=BminGen
        BminLoc[l]=np.array(j)
        BminLoc[l][np.isnan(BminLoc[l])]=0
    

    CondLoc=[[np.ones(np.shape(t), dtype=bool)],[R-t>0],[t-R>=0],[t-R>=0],[t-R>=0]]

    for i,j in enumerate(CondLoc):
        j+=np.ndarray.tolist(CondGen)
        CondLoc[i]=np.array(j)
    
    Bornes=[]
    for k,l in enumerate(CondLoc):
        BMax=np.amin(BMaxLoc[k],axis=0) #Taking the upper bounds' minimum, excluding NaNs
        Bmin=np.amax(BminLoc[k],axis=0) #Taking the lower bounds' maximum, excluding NaNs
        
        CondFailed=np.logical_not(np.all(l,axis=0)) # Set as True where conditions are not met
        
        BMax[CondFailed]=0 # Bounds set to 0 so that the function gives 0 on these points
        Bmin[CondFailed]=0
        
        minGtMax=np.greater_equal(Bmin,BMax) # Returns True where lower bound is >= upper bound
        
        BMax[minGtMax]=0 # Bounds set to 0 so that the function gives 0 on these points
        Bmin[minGtMax]=0
        
        Bornes.append([BMax,Bmin])
    

    Sol=np.zeros(np.shape(z))
    for i,j in enumerate(FoncList):
        Sol+=j(Bornes[i][0],z,t,R)-j(Bornes[i][1],z,t,R)

            
    return Sol
   
   
